package AdapterPattern.ObjectAdapter;

/*
 * 类适配器与对象适配器比较：、
 * 1.类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式
 * 
 * 2.类适配器是继承Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系
 * 		对象适配器采用的是对象组合的关系，同一个适配器可以把源类和它的子类都适配到目标接口
 * 
 * 3.类适配器可以重新定义Adaptee的部分行为，因为是继承关系，相当于子类覆盖父类的一些方法
 * 	对象适配器要重新定义Adaptee行为比较困难，需要使用Adaptee的子类来实现重新定义，然后让适配器组合子类
 * 	虽然对象适配器重定义Adaptee行为比较困难，但是要增加一些新的行为则比较简单，且增加的行为适用于所有的源类及其子类
 * 
 * 4.类适配器模式只需要一个对象，而对象适配器模式还需要间接地引用一个Adaptee对象
 * 
 * 一般而言，基于多用组合，少用继承的原则。尽量使用对象适配器模式，但是实际使用时要根据实际情况确定
 */

/*
 * 适配器模式的优点：
 * 1.更好的复用性：系统需要使用现有的类，但是类的接口不符合系统需要，那么通过适配器能使这些功能得到更好的复用
 * 2.更好的扩展性：实现适配器功能的时候，可以调用自己开发的其他功能，从而自然的扩展系统的功能
 * 
 * 适配器模式的缺点：
 * 过多的使用适配器模式会使系统相当凌乱，不易对整体进行把握
 * 例如：明明看到调用的是A接口，其实内部被适配成了B接口的实现。如果系统中出现过多这种情况会是灾难性的
 * 因此如果不是必要，可以不使用适配器，而是直接对代码进行重构
 */

/*
 * 对象适配器模式：与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API
 * 不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。
 */
public class Adapter {
	private Adaptee adaptee;

	/**
	 * 通过构造器接收一个Adaptee对象
	 */
	public Adapter(Adaptee adaptee) {
		this.adaptee = adaptee;
	}

	/**
	 * 源类Adaptee有方法sampleOperation1
	 * 因此适配器类直接委派即可
	 */
	public void sampleOperation1() {
		this.adaptee.sampleOperation1();
	}

	/**
	* 源类Adaptee没有方法sampleOperation2
	* 因此由适配器类需要补充此方法
	*/
	public void sampleOperation2() {
		// 写相关的代码
	}
}
