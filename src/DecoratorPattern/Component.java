package DecoratorPattern;

/*
 * 装饰器模式（Decorator）又叫包装器模式（Wrapper）
 * 装饰器模式的目的是以客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。
 * 装饰器模式可以以客户端透明的方式动态的给一个对象附加上更多的责任，而客户端并不知道装饰前后的变化
 */

/*
 * 简化装饰器模式
 * 在大多数情况下，装饰器模式的实现都比标准模式要简单得多
 * 1.如果只有一个ConcreteComponent的情况下，可以考虑取消Component接口，Decorator直接作为ConcreteComponent的一个子类
 * 2.如果只有一个ConcreteDecorator类，没有必要单独建一个Decorator，甚至有两个ConcreteDecorator也可以这样做
 */

/*
 * 装饰器模式的透明性要求
 * 客户端不要声明一个ConcreteComponent的变量，而应当申明一个Component的变量
 * 无论怎么装饰，这个变量都是Component类型的
 */

/*
 * 半透明的装饰模式
 * 纯粹的装饰器模式很难找到，装饰器模式的用意是在不改变接口的情况下，增强类的性能。
 * 然而在增强性能的时候，往往需要添加新的功能，如例子中，鸟有飞的功能，那么就需要增加fly()方法，
 * 鱼有游泳的功能，那么就需要增加swim()方法
 * 
 * 这就导致了大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，增加新的方法。
 * 
 * 这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法
 * 半透明的装饰模式是介于装饰模式和适配器模式之间的。
 * 适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。
 * 
 * 大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。
 */

/*
 * 装饰器模式的优缺点
 * 优点：
 * 1.装饰器模式和继承的目的都是扩展对象的功能，但是装饰器模式比继承更加灵活。
 * 		装饰器模式允许动态的添加一个“装饰”，或者除掉一个不需要的“装饰”
 * 		而继承关系是静态的，在系统运行前就已经决定了。
 * 2.通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。
 * 3.具体装饰器或者被装饰类较多的情况下，使用装饰器模式比继承所需要的类更少，系统也更易于设计
 * 
 * 缺点：
 * 装饰器模式使用过程中会产生比继承关系更多的对象，这样会使查错变得困难，尤其是这些对象看上去都很像
 */

/*
 * 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。
 */

public interface Component {
	public void sampleOperation();
}
