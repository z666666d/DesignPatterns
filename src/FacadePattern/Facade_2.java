package FacadePattern;

/*
 * 外观模式还有一个附带的好处，就是能够有选择性地暴露方法。
 * 一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。
 * 有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。
 * 如D、E、F模块
 * 
 * Facade_2类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。
 * 比如a2()和a3()方法就不需要让客户端知道，否则既暴露了内部的细节，又让客户端迷惑。
 * a2()和a3()方法是内部模块之间交互的，原本就不是对子系统外部的，所以干脆就不要让客户端知道。
 */

/* 一个系统可以有几个门面类
 * 在外观模式中，一般只有一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。
 * 当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。
 * 如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。
 */

/*
 * 不要通过门面类为子系统增加新行为
 * 门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为
 * 比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。
 */

/*
 * 门面模式的优点
 * 1.松散耦合：门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。
 * 2.简单易用：门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，
 * 				也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了。
 * 3.更好的划分访问层次：
 * 			通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。
 * 			把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。
 */
public class Facade_2 {
	ModuleD a = new ModuleD();
	ModuleE b = new ModuleE();
	ModuleF c = new ModuleF();

	/**
	 * 下面这些是D、E、F模块对子系统外部提供的方法
	 */
	public void a1() {
		a.a1();
	}

	public void b1() {
		b.b1();
	}

	public void c1() {
		c.c1();
	}
}
