享元模式是一种对象的结构模式，以共享的方式高效地支持大量的细粒度对象

Flyweight拳击比赛中指最轻量级，这里翻译成享元抓住了这个模式的关键，可以理解为共享元对象(细粒度对象)的意思
享元模式的定义为：采用一个共享来避免大量拥有相同内容对象的开销。这种开销中最常见、直观的就是内存的损耗。

在Java中的String类型就使用了享元模式，String对象是final类型的，对象一旦创建就不可改变
在Java中的字符串量都是存在常量池中的，Java会确保一个字符串常量在常量池中只有一个拷贝
这样的设计避免了在创建N多相同对象时所产生的不必要的大量的资源消耗。

享元对象能做到共享的关键是区分内蕴状态(Internal State)和外蕴状态(External State)。
一个内蕴状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内蕴状态并可以共享。

一个外蕴状态是随环境的改变而改变的、不可以共享的。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，
在需要使用的时候再传入到享元对象内部。外蕴状态不可以影响享元对象的内蕴状态，它们是相互独立的。

享元模式可以分成单纯享元模式和复合享元模式两种形式。


享元模式的优缺点
优点在于它大幅度地降低内存中对象的数量。

缺点：
1.使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。
2.将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。

享元模式在一般的项目开发中并不常用，而是常常应用于系统底层的开发，以便解决系统的性能问题。
比如Java中的String类型就是使用了享元模式。

需要用到享元模式的情况：
1.一个系统中存在着大量的细粒度对象；
2.这些细粒度对象耗费了大量的内存。 
3.这些细粒度对象的状态中的大部分都可以外部化； 
4.这些细粒度对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组都可以仅用一个对象代替。 
5.软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。

满足以上的这些条件的系统可以使用享元对象。


使用享元模式需要维护一个记录了系统已有的所有享元的哈希表，也称之为对象池，而这也需要耗费一定的资源。
因此，应当在有足够多的享元实例可供共享时才值得使用享元模式。


